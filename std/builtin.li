/// Copyright (c) 2021 zakuro <z@kuro.red>. All rights reserved.
///
/// This Source Code Form is subject to the terms of the Mozilla Public
/// License, v. 2.0. If a copy of the MPL was not distributed with this
/// file, You can obtain one at https://mozilla.org/MPL/2.0/.

fn print(s: string) {
  sh { printf '%%s' "$%s" }
}

fn println(s: string) {
  sh { printf '%%s\n' "$%s" }
}

fn eprint(s: string) {
  sh { printf '%%s' "$%s" >&2 }
}

fn eprintln(s: string) {
  sh { printf '%%s\n' "$%s" >&2 }
}

fn isatty(): bool {
  var true_ = true
  var res = false
  sh {
    if [ -t 0 ]
    then
      %res=$%true_
    fi
  }
  return res
}

fn has(command: string): bool {
  var code: int
  sh {
    type $%command > /dev/null 2>&1
    %code=$?
  }
  return code == 0
}

fn ...string |> join(sep: string) |> string {
  var ret = ''
  var (i, s): (int, string)
  while read(&s) {
    if i > 0 {
      ret += sep
    }
    ret += s
    i += 1
  }
  return ret
}

fn range(begin: int, end: int) |> ...int {
  // cannot use negative number on busybox
  for i in @seq(0, end - begin - 1) as ...int {
    yield (i as int) + begin
  }
}

// -- posix --

fn exit(code: int)

fn string |> cat(files: ...string) |> ...string

fn seq(n: int) |> ...int

fn basename(path: string): string

fn cd(path: string)

fn dirname(path: string): string

fn mkdir(args: ...string)

fn mkdir_p(args: ...string) {
  sh {
    mkdir -p "$@"
  }
}

fn pwd(): string

fn ls(files: ...string) |> ...string

fn rm(paths: ...string)

fn rm_r(paths: ...string) {
  sh {
    rm -r "$@"
  }
}

fn touch(files: ...string)

#[mangle]
fn which(name: string): string {
  var res: string
  sh {
    %res=$(which $%name)
    if [ $? -ne 0 ]
    then
      %res=''
    fi
  }
  return res
}

// --- string methods ---

fn (s: string) replace(a: string, b: string): string {
  return s |> @sed("s/$a/$b/g")
}

fn (s: string) substr(i: int, n: int): string {
  return (s |> @awk('-v', 'RS=""', '-v', "m=${i + 1}", '-v', "n=$n", '{print substr($0, m, n)}'))
}

fn (s: string) index(t: string): int {
  if t.len() == 0 {
    return 0
  }
  return (s |> @awk('-v', "t=$t", '{print index($1, t) - 1}')) as int
}

fn (s: string) last_index(t: string): int {
  var s_len = s.len()
  if t.len() == 0 {
    return s_len
  }

  // TODO: this implementation is inefficient

  var last_i = -1
  var rest = s
  while true {
    var i = rest.index(t)
    if i < 0 {
      break
    }
    last_i = i + (s_len - rest.len())
    rest = rest.substr(i + t.len(), rest.len())
  }
  return last_i
}

fn (s: string) len(): int {
  var n: int
  sh { %n=${#%s} }
  return n
}

fn (s: string) starts_with(ss: string): bool {
  if ss.len() == 0 {
    return true
  }
  if ss.len() > s.len() {
    return false
  }
  if ss == s {
    return true
  }
  return s.index(ss) == 0
}

fn (s: string) ends_with(ss: string): bool {
  if ss.len() == 0 {
    return true
  }
  if ss.len() > s.len() {
    return false
  }
  if ss == s {
    return true
  }
  return s.last_index(ss) == s.len() - ss.len()
}

fn (s: string) trim_prefix(prefix: string): string {
  if !s.starts_with(prefix){
    return s
  }
  return s.substr(prefix.len(), s.len())
}

fn (s: string) trim_suffix(suffix: string): string {
  if !s.ends_with(suffix) {
    return s
  }
  return s.substr(0, s.len() - suffix.len())
}

fn (s: string) trim_start(): string {
  return s |> @sed('s/^[[:space:]]*//')
}

fn (s: string) trim_end(): string {
  return s |> @sed('s/[[:space:]]*$//')
}

fn (s: string) trim(): string {
  return s.trim_start().trim_end()
}

fn (s: string) contains(substr: string): bool {
  return s.index(substr) >= 0
}

// --- array methods ---
// All array inherits []any

fn (arr: []any) len(): int {
  var n: int
  sh { %n=$(array_len %arr) }
  return n
}

fn (ss: []string) join(sep: string): string {
  if ss.len() == 0 {
    return ''
  }
  var ret: string
  for i in range(0, ss.len()) {
    if i > 0 {
      ret += sep
    }
    ret += ss[i]
  }
  return ret
}
