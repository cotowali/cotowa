// Copyright (c) 2021 zakuro <z@kuro.red>. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

echo('Ray tracing example')

// --------------------

fn vec3(x: float, y: float, z: float) (float, float, float) {
  return (x, y, z)
}

fn vec3_x(v: (float, float, float)) float {
  var (x, y, z) = v
  return x
}

fn vec3_y(v: (float, float, float)) float {
  var (x, y, z) = v
  return y
}

fn vec3_z(v: (float, float, float)) float {
  var (x, y, z) = v
  return z
}

fn vec3_length_squared(v: (float, float, float)) float {
  var (x, y, z) = v
  return x * x + y * y + z * z
}

fn vec3_length(v: (float, float, float)) float {
  return (vec3_length_squared(v) |> @awk('{print sqrt($1)}')) as float
}

fn vec3_normalize(v: (float, float, float)) (float, float, float) {
  return vec3_divide(v, vec3_length(v))
}

fn vec3_add(v1: (float, float, float), v2: (float, float, float)) (float, float, float) {
  return vec3(
    vec3_x(v1) + vec3_x(v2),
    vec3_y(v1) + vec3_y(v2),
    vec3_z(v1) + vec3_z(v2),
  )
}

fn vec3_subtract(v1: (float, float, float), v2: (float, float, float)) (float, float, float) {
  return vec3(
    vec3_x(v1) - vec3_x(v2),
    vec3_y(v1) - vec3_y(v2),
    vec3_z(v1) - vec3_z(v2),
  )
}

fn vec3_multiply(v: (float, float, float), n: float) (float, float, float) {
  return vec3(vec3_x(v) * n, vec3_y(v) * n, vec3_z(v) * n)
}

fn vec3_divide(v: (float, float, float), n: float) (float, float, float) {
  return vec3(vec3_x(v) / n, vec3_y(v) / n, vec3_z(v) / n)
}

fn vec3_cross(v1: (float, float, float), v2: (float, float, float)) (float, float, float) {
  return vec3(
    vec3_y(v1) * vec3_z(v2) - vec3_z(v1) * vec3_y(v2),
    vec3_z(v1) * vec3_x(v2) - vec3_x(v1) * vec3_z(v2),
    vec3_x(v1) * vec3_y(v2) - vec3_y(v1) * vec3_x(v2),
  )
}

fn vec3_dot(v1: (float, float, float), v2: (float, float, float)) float {
  return vec3_x(v1) * vec3_x(v2) + vec3_y(v1) * vec3_y(v2) + vec3_z(v1) * vec3_z(v2)
}

fn test_vec3() {
  var v1 = vec3(1.0, 2.0, 3.0)
  var v2 = vec3(4.0, 5.0, 6.0)

  assert vec3_length_squared(v1) == 14
  var v1_len = vec3_length(v1)
  assert 3.7 < v1_len && v1_len < 3.8

  var normalized_v1 = vec3_normalize(v1)
  assert 0.99 < vec3_length(normalized_v1) && vec3_length(normalized_v1) < 1.01

  var added = vec3_add(v1, v2)
  assert vec3_x(added) == 5 && vec3_y(added) == 7 && vec3_z(added) == 9

  var diff = vec3_subtract(v2, v1)
  assert vec3_x(diff) == 3 && vec3_x(diff) == 3 && vec3_x(diff) == 3

  var twice_v1 = vec3_multiply(v1, 2)
  assert vec3_x(twice_v1) == 2 && vec3_y(twice_v1) == 4 && vec3_z(twice_v1) == 6

  var half_v1 = vec3_divide(v1, 2)
  assert vec3_x(half_v1) == 0.5 && vec3_y(half_v1) == 1.0 && vec3_z(half_v1) == 1.5

  var cross = vec3_cross(v1, v2)
  assert vec3_x(cross) == -3 && vec3_y(cross) == 6 && vec3_z(cross) == -3

  assert vec3_dot(v1, v2) == 1 * 4 + 2 * 5 + 3 * 6
  assert vec3_dot(v1, cross) == 0
  assert vec3_dot(v2, cross) == 0
}
test_vec3()

// --------------------

fn sphere(center: (float, float, float), radius: float) (float, float, float, float) {
  var (x, y, z) = center
  return (x, y, z, radius)
}

fn sphere_center(sphere: (float, float, float, float)) (float, float, float) {
  var (x, y, z, radius) = sphere
  return vec3(x, y, z)
}

fn sphere_radius(sphere: (float, float, float, float)) float {
  var (x, y, z, radius) = sphere
  return radius
}

fn test_sphere() {
  var center = vec3(0, -1, 1)
  var sp = sphere(center, 3)

  var c = sphere_center(sp)
  assert
    vec3_x(c) == 0 &&
    vec3_y(c) == -1 &&
    vec3_z(c) == 1
  assert sphere_radius(sp) == 3
}
test_sphere()
