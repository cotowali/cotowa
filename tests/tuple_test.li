fn swap(a: int, b: int) (int, int) {
  return (b, a)
}

fn test_swap() {
  var a = 1
  var b = 2
  var new_a = a
  var new_b = a
  (new_a, new_b) = swap(a, b)
  assert new_a == b && new_b == a
}

test_swap()

fn ...int |> sum() |> int {
  var res = 0
  var v: int
  while read(&v) {
    res = res + v
  }
  return res
}


fn ...(int, int) |> add() |> ...int {
  var v1: int
  var v2: int
  while read(&v1, &v2) {
    yield v1 + v2
  }
}

fn (int) |> twice() |> (int) {
  var n: int
  read(&n)
  return n * 2
}

assert ((1, 2) |> add() |> sum()) == 3
assert ((3) |> twice()) == 6
assert (3 |> twice()) == (6)

fn () |> zero() int {
  return 0
}
assert (() |> zero()) == 0

fn tuple_add(a: (int, int), b: (int, int)) (int, int) {
  var (a1, a2) = a
  var (b1, b2) = b
  return (a1 + b1, a2 + b2)
}

fn test_tuple_args() {
  var a = (1, 2)
  var b = (5, 6)
  var (c1, c2) = tuple_add(a, b)
  assert c1 == 6 && c2 == 8
  var (d1, d2) = tuple_add((2, 3), (8, 9))
  assert d1 == 10 && d2 == 12
}
test_tuple_args()

/*
fn ((int, int), (int, int)) |> pair_sub() (int, int) {
  var left (int, int)
  var right (int, int)
  read(&left, &right)
  var left_a int
  var left_b int
  (left_a, left_b) = left
  var right_a int
  var right_b int
  (right_a, right_b) = right

  return (left_a - left_b, right_a - right_b)
}

// (5 - 2) + (1 - 2) == 2
assert (((5, 2), (1, 2)) |> pair_sub() |> add() |> sum()) == 2
*/
