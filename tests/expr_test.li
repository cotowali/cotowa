assert 6 / 2 + 3 * 3 == 12
assert 1 + 1 - 1 == 1
assert 6 / 2 % 2 == 1
assert (1 + 2) * (4 - 2) == 6
assert (0.9 + 2.1) * (2.2 / 4.4) == 1.5

assert 1 / 2 == 0
assert 1.0 / 2 == 0.5
assert 1 / 2.0 == 0.5

var v = 1
v = 10
assert -v == -10
assert +v == 10
assert -+v == +-v
assert - -v == + +v
assert - - -v == -v


assert 0 < 1
assert 0.1 < 0.2
assert 0.5 < 1
assert 0 < 0.5

assert 0 <= 1
assert 0.1 <= 0.2
assert 0.5 <= 1
assert 0 <= 0.5

assert 0 <= 0
assert 0.1 <= 0.1

assert 1 > 0
assert 0.2 > 0.1
assert 1 > 0.5
assert 0.5 > 0

assert 1 >= 0
assert 0.2 >= 0.1
assert 1 >= 0.5
assert 0.5 >= 0
assert 0 >= 0
assert 0.1 >= 0.1

assert 0 == 0 && 1 != 0
assert 0 == 0 || 1 == 0
assert 1 == 0 || 0 == 0

assert '10' == '10'
assert '10' != '11'
assert '10' + '10' == '1010'

if true {
  assert true
} else {
  assert false
}

if false {
  assert false
} else {
  assert true
}

assert (1 == 1) == true
assert (1 == 0) == false
assert (1 == 1) == (1 == 1)
assert (1 == 0) == (1 == 0)
assert (1 == 0) != (1 == 1)
assert (1 == 1) != (1 == 0)

fn zero() int {
  var v = 0

  // evaluated but not used. this is valid but no output
  0
  v
  add(1, 2)

  return v
}

fn add(a int, b int) int {
  return a + b
}

fn as_int(v any) int {
  return v as int
}

assert zero() == 0
assert add(3, 4) == 7
assert add(as_int("1"), 2) == 3

fn int |> inc() int {
  var n = 0
  read(&n)
  return n + 1
}

fn ...int |> sum() int {
  var n int
  var v int
  while read(&v) {
    n = n + v
  }
  return n
}

fn ...int |> twice() |> ...int {
  var v int
  while read(&v) {
    yield v * 2
  }
}

assert (10 |> inc()) == 11
assert (10 |> sum()) == 10
assert (seq(3) |> sum()) == 6
assert (seq(3) |> twice() |> sum()) == 12

assert call('add', '3', '4') == '7'

